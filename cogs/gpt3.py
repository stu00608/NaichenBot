"""
This file contains a cog for the GPT-3 helper commands.
"""

import os
import asyncio
import openai
import discord
from discord.ext import commands
from typing import List, Optional
from collections import deque
import assets.settings.setting as setting


logger = setting.logging.getLogger("gpt3")

openai.api_key=os.getenv("OPENAI_API_KEY")

def prepare_codex_prompt(strings: List[str]) -> str:
    """Generate a string with a numbering pattern for a given list of strings.

    Args:
        strings: A list of strings to be formatted.

    Returns:
        A string with the desired pattern, including triple quotes at the beginning and end. Each string in the list is
        formatted with a numbering prefix, starting from 1 and incrementing by 1 for each string.
    """
    # Initialize an empty list to store the formatted strings
    formatted_strings = []

    # Iterate over the list of strings
    for i, s in enumerate(strings):
        # Format the string with the desired pattern
        formatted_string = f"{i+1}. {s}"
        # Append the formatted string to the list
        formatted_strings.append(formatted_string)

    # Join the list of formatted strings with newline characters
    result = "\n".join(formatted_strings)

    # Return the result wrapped in triple quotes
    return f"\"\"\"\n{result}\n\"\"\""

async def generate_code(prompt):
    """
    Requests a completion from the OpenAI Code-DaVinci-002 model and returns the completion as a string.
    
    Parameters:
    - prompt (str): The prompt for which to generate a completion.
    
    Returns:
    - completion (str): The completion generated by the model.
    """
    completions = openai.Completion.create(
        engine="code-davinci-002",
        prompt=prompt,
        max_tokens=1024,
        n=1,
        temperature=0.5,
        stop="\"\"\""
    )
    return completions.choices[0].text

def append_conversation(prompt, message):
    """Append a message to the conversation prompt."""
    res = f"{prompt}Human: {message}\nKoto: "
    return res

async def generate_conversation(prompt):
    """
    Requests a completion from the OpenAI Text-DaVinci-002 model and returns the completion as a string.

    Parameters:
    - prompt (str): The prompt for which to generate a completion.

    Returns:
    - completion (str): The completion generated by the model.
    """
    completions = openai.Completion.create(
        engine="text-davinci-002",
        prompt=prompt,
        max_tokens=150,
        temperature=0.9,
        top_p=1,
        frequency_penalty=0,
        presence_penalty=0.6,
        stop=["\n", " Human:", " Koto:"]
    )
    message = completions.choices[0].text
    return message

class GPT3Helper(commands.Cog):
    """Cog for GPT-3 helper commands. This cog contains commands for generating code and conversation completions.
    
    Properties:
    - bot (commands.Bot): The bot instance.
    - chat_flag (bool): A flag to indicate whether the chat function in on_message is on or off.
    - conversation (str): The full conversation prompt.
    - content (collections.deque): A deque to store the last 5 messages sent in the chat channel.

    Methods:
    - update_conversation: Update the conversation prompt. Read original conversation material from disk and append conversations from a deque.
    - auto_shutup: A coroutine to turn off the chat function after 10 minutes.

    Commands:
    - update_api_key: Set the OpenAI API key.
    - code: Generate a code completion.
    - chat: Turn on the chat function.
    """
    def __init__(self, bot):
        self.bot = bot

        self.chat_flag = False
        self.conversation = "" 
        self.content = deque(maxlen=5)
        self.update_conversation()
    
    def update_conversation(self):
        with open("assets/texts/conversation.txt") as f:
            self.conversation = f.read()
        for h, k in self.content:
            self.conversation = append_conversation(self.conversation, h)
            self.conversation += k
    
    async def auto_shutup(self):
        try:
            await asyncio.sleep(300)  # pause for 10 minutes
            self.chat_flag = False
            logger.info("Chat function turned off.")
        except asyncio.CancelledError:
            # Task was cancelled, do any necessary cleanup and exit
            return

    @commands.Cog.listener()
    async def on_message(self, message):
        if message.author == self.bot.user:
            # message author is not the bot itself
            return
        if not message.guild:
            # message is from a dm
            return
        if self.chat_flag:
            prompt = append_conversation(self.conversation, message.content)
            try:
                async with message.channel.typing():
                    response = await generate_conversation(prompt)
            except openai.error.InvalidRequestError as e:
                logger.error(e)
                await message.channel.send("請求出現錯誤！有可能是請求的主體超出token的限制。如果一直出現這個錯誤，麻煩跟奶辰說一下，謝謝！")
                return
            except openai.error.APIError as e:
                logger.error(e)
                await message.channel.send("在請求OpenAI的時候出現API錯誤！如果一直出現這個錯誤，麻煩稍等一些時間再繼續使用，謝謝！")
                return
            except openai.error.ServiceUnavailableError as e:
                logger.error(e)
                await message.channel.send("OpenAI的服務目前不可用！如果一直出現這個錯誤，麻煩稍等一些時間再繼續使用，謝謝！")
                return

            self.content.append((message.content, response+"\n"))
            self.update_conversation()
            await message.channel.send(response)
            if self.auto_shutup_task:
                self.auto_shutup_task.cancel()
                self.auto_shutup_task = asyncio.create_task(self.auto_shutup())
    
    @commands.command(name="update_api_key")
    @commands.has_permissions(administrator=True)
    async def _update_api_key(self, ctx, key):
        if key is None:
            return
        await ctx.defer()
        openai.api_key=key
        await ctx.send(f"Updated OpenAI API key")

    @commands.hybrid_command(name="code", description="Call OpenAI code-davinci-002 API to generate code piece by providing prompts.")
    async def _code(self, ctx, *, prompt: Optional[str]):
        if prompt is None:
            return
        await ctx.defer()
        fixed_prompt = prepare_codex_prompt(prompt.split(". "))
        code = await generate_code(fixed_prompt)
        await ctx.send(f"{fixed_prompt}")
        try:
            await ctx.send(f"```python\n{code}\n\n```")
        except Exception as e:
            tmp = "tmp/generated_code.py"
            with open(tmp, "w") as f:
                f.write(f"{fixed_prompt}\n{code}")
            await ctx.send("傳送訊息時出現錯誤！可能是長度超過Discord的限制，Code將以檔案的形式傳送。", files=[discord.File(tmp)])
            await asyncio.sleep(3)
            os.remove(tmp)


    @commands.hybrid_command(name="chat", description="Turn on/off the chat function with Koto.")
    async def _chat(self, ctx):
        await ctx.defer()
        if self.chat_flag:
            if self.auto_shutup_task:
                self.auto_shutup_task.cancel()
                self.auto_shutup_task = None
            self.chat_flag = False
            await ctx.send("Chat function turned off.")
        else:
            self.chat_flag = True
            self.auto_shutup_task = asyncio.create_task(self.auto_shutup())
            self.conversation = "" 
            self.content = deque(maxlen=5)
            self.update_conversation()
            await ctx.send("Chat function turned on.")

async def setup(client):
    await client.add_cog(GPT3Helper(client))